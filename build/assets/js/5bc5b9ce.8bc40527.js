"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[3457],{6993:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var i=t(4848),s=t(8453);const o={title:"Bridge between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},r=void 0,a={id:"build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",title:"Bridge between Morph and Ethereum",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!",source:"@site/docs/build-on-morph/build-on-morph/3-bridge-between-morph-and-ethereum.md",sourceDirName:"build-on-morph/build-on-morph",slug:"/build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",permalink:"/docs/build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",draft:!1,unlisted:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/build-on-morph/build-on-morph/3-bridge-between-morph-and-ethereum.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Bridge between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},sidebar:"DevSidebar",previous:{title:"Devlopement Setup",permalink:"/docs/build-on-morph/build-on-morph/development-setup"},next:{title:"Understand Transaction Cost on Morph",permalink:"/docs/build-on-morph/build-on-morph/understand-transaction-cost-on-morph"}},d={},c=[{value:"Bridging basics",id:"bridging-basics",level:2},{value:"Sending tokens",id:"sending-tokens",level:3},{value:"Sending data",id:"sending-data",level:3},{value:"Utilize Standard Bridge Contract",id:"utilize-standard-bridge-contract",level:2},{value:"Deposits",id:"deposits",level:2},{value:"Depositing ERC20s",id:"depositing-erc20s",level:3},{value:"Depositing ETH",id:"depositing-eth",level:3},{value:"Withdrawals",id:"withdrawals",level:2},{value:"Withdrawing ERC20s",id:"withdrawing-erc20s",level:3},{value:"Withdrawing ETH",id:"withdrawing-eth",level:3},{value:"Send messages between Morph and Ethereum",id:"send-messages-between-morph-and-ethereum",level:2},{value:"Communication basics between layers",id:"communication-basics-between-layers",level:3},{value:"Fees for L2 \u21d2 L1 transactions",id:"fees-for-l2--l1-transactions",level:3},{value:"Understanding the challenge period",id:"understanding-the-challenge-period",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"bridging-basics",children:"Bridging basics"}),"\n",(0,i.jsx)(n.p,{children:"Although Morph is an Ethereum Layer 2 (and therefore fundamentally connected to Ethereum), it's also a separate blockchain system."}),"\n",(0,i.jsx)(n.p,{children:'App developers often have a need to move data and assets between Morph and Ethereum, a process we call "bridging".'}),"\n",(0,i.jsx)(n.h3,{id:"sending-tokens",children:"Sending tokens"}),"\n",(0,i.jsx)(n.p,{children:"For the most common usecase, moving tokens around, we've created the Standard Token Bridge. The Standard Token Bridge is a simple smart contract with all the functionality you need to move tokens between Morph and Ethereum. It also allows you to easily create L2 representations of existing tokens on Ethereum."}),"\n",(0,i.jsx)(n.h3,{id:"sending-data",children:"Sending data"}),"\n",(0,i.jsxs)(n.p,{children:["If the Standard Token Bridge doesn't fully cover your usecase, you can also ",(0,i.jsx)(n.a,{href:"#send-messages-between-morph-and-ethereum",children:"send arbitrary data between L1 and L2"}),". You can use this functionality to have a contract on Ethereum trigger a contract function on Morph, and vice versa."]}),"\n",(0,i.jsx)(n.p,{children:"We've made this process as easy as possible by giving developers a simple API for triggering a cross-chain function call."}),"\n",(0,i.jsx)(n.h2,{id:"utilize-standard-bridge-contract",children:"Utilize Standard Bridge Contract"}),"\n",(0,i.jsx)(n.p,{children:'To facilitate common interactions like transferring ETH and ERC20 tokens between the two networks, we offer the "Standard Bridge". This bridge simplifies the transfer of assets between L1 and L2.'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Standard Bridge Functionality: It allows for ETH or ERC20 token to be deposited on L1 and locked in exchange for an equivalent amount on L2, and vice versa. This is known as "bridging a token," e.g., depositing 100 USDC on L1 for 100 USDC on L2. .'}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The Standard Bridge is composed of two main contracts the ",(0,i.jsx)(n.a,{href:"https://github.com/morph-l2/contracts/tree/main/contracts/L1/L1StandardBridge.sol",children:(0,i.jsx)(n.code,{children:"L1StandardBridge"})})," (for Layer 1) and the ",(0,i.jsx)(n.a,{href:"https://github.com/morph-l2/contracts/tree/main/contracts/L2/L2StandardBridge.sol",children:(0,i.jsx)(n.code,{children:"L2StandardBridge"})})," (for Layer 2)."]}),"\n",(0,i.jsx)(n.p,{children:"Here we'll go over the basics of using this bridge to move tokens between Layer 1 and Layer 2."}),"\n",(0,i.jsx)(n.h2,{id:"deposits",children:"Deposits"}),"\n",(0,i.jsx)(n.h3,{id:"depositing-erc20s",children:"Depositing ERC20s"}),"\n",(0,i.jsxs)(n.p,{children:["ERC20 deposits into L2 can be triggered via the ",(0,i.jsx)(n.code,{children:"depositERC20"})," and ",(0,i.jsx)(n.code,{children:"depositERC20To"})," functions on the ",(0,i.jsx)(n.a,{href:"https://github.com/morph-l2/contracts/tree/main/contracts/L1/L1StandardBridge.sol",children:(0,i.jsx)(n.code,{children:"L1StandardBridge"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Ensure the Standard Token Bridge is ",(0,i.jsx)(n.strong,{children:"approved"})," to use the tokens you wish to deposit."]}),"\n",(0,i.jsx)(n.h3,{id:"depositing-eth",children:"Depositing ETH"}),"\n",(0,i.jsxs)(n.p,{children:["ETH deposits into L2 can be triggered via the ",(0,i.jsx)(n.code,{children:"depositETH"})," and ",(0,i.jsx)(n.code,{children:"depositETHTo"})," functions on the ",(0,i.jsx)(n.a,{href:"https://github.com/morph-l2/contracts/tree/main/contracts/L1/L1StandardBridge.sol#L119C20-L119C20",children:(0,i.jsx)(n.code,{children:"L1StandardBridge"})}),".\nETH deposits can alternatively be triggered by sending ETH directly to the ",(0,i.jsx)(n.code,{children:"L1StandardBridge"}),".\nOnce your deposit is detected and finalized, your account will be funded with the corresponding amount of ETH on L2."]}),"\n",(0,i.jsx)(n.h2,{id:"withdrawals",children:"Withdrawals"}),"\n",(0,i.jsx)(n.h3,{id:"withdrawing-erc20s",children:"Withdrawing ERC20s"}),"\n",(0,i.jsxs)(n.p,{children:["ERC20 withdrawals can be triggered via the ",(0,i.jsx)(n.code,{children:"withdraw"})," or ",(0,i.jsx)(n.code,{children:"withdrawTo"})," functions on the ",(0,i.jsx)(n.a,{href:"https://github.com/morph-l2/contracts/tree/main/contracts/L2/L2StandardBridge.sol#L121",children:(0,i.jsx)(n.code,{children:"L2StandardBridge"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"withdrawing-eth",children:"Withdrawing ETH"}),"\n",(0,i.jsxs)(n.p,{children:["Unlike on L1, we do not have a separate function on L2 for withdrawing ETH.\nInstead, you can use the ",(0,i.jsx)(n.code,{children:"withdraw"})," or ",(0,i.jsx)(n.code,{children:"withdrawTo"})," functions on the ",(0,i.jsx)(n.a,{href:"https://github.com/morph-l2/contracts/tree/main/contracts/L2/L2StandardBridge.sol#L121",children:(0,i.jsx)(n.code,{children:"L2StandardBridge"})})," and use the address ",(0,i.jsx)(n.code,{children:"0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000"})," as the L2 token address."]}),"\n",(0,i.jsx)(n.h2,{id:"send-messages-between-morph-and-ethereum",children:"Send messages between Morph and Ethereum"}),"\n",(0,i.jsxs)(n.p,{children:['Apps on Morph can be made to interact with apps on Ethereum via a process called "bridging".\nIn a nutshell, ',(0,i.jsx)(n.strong,{children:"contracts on Morph can trigger contract functions on Ethereum, and vice versa"}),".\nWith just a little bit of elbow grease, you also can create contracts that bridge the gap between Layer 1 and Layer 2!"]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:(0,i.jsx)("b",{children:"Understanding contract calls"})}),(0,i.jsxs)(n.p,{children:["To understand the process of creating bridges between contracts on Layer 1 and Layer 2, you should first have a basic understanding of the way contracts on ",(0,i.jsx)(n.em,{children:"Ethereum"})," communicate with one another.\nIf you're a smart contract developer, you might be familiar with stuff like this:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"contract MyContract {\n    function doSomething(uint256 myFunctionParam) public {\n        // ... some sort of code goes here\n    }\n}\n\ncontract MyOtherContract {\n    function doTheThing(address myContractAddress, uint256 myFunctionParam) public {\n        MyContract(myContractAddress).doSomething(myFunctionParam);\n    }\n}\n"})}),(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"MyOtherContract.doTheThing"}),' triggers a "call" to ',(0,i.jsx)(n.code,{children:"MyContract.doSomething"}),'.\nA "call" is defined by a few key input parameters, mainly a ',(0,i.jsx)(n.code,{children:"target address"})," and some ",(0,i.jsx)(n.code,{children:"calldata"}),".\nIn this specific example, the ",(0,i.jsx)(n.code,{children:"target address"})," is going to be the address of our instance of ",(0,i.jsx)(n.code,{children:"MyContract"}),".\nThe ",(0,i.jsx)(n.code,{children:"calldata"}),", on the other hand, depends on the function we're trying to call.\nSolidity uses an encoding scheme called ",(0,i.jsx)(n.a,{href:"https://docs.soliditylang.org/en/v0.8.4/abi-spec.html",children:"Contract ABI"})," to both ",(0,i.jsx)(n.a,{href:"https://docs.soliditylang.org/en/v0.8.4/abi-spec.html#function-selector",children:"select which function to call"})," and to ",(0,i.jsx)(n.a,{href:"https://docs.soliditylang.org/en/v0.8.4/abi-spec.html#argument-encoding",children:"encode function input arguments"}),"."]}),(0,i.jsx)(n.p,{children:"Solidity gives us some useful tools to perform this same encoding manually.\nFor the sake of learning, let's take a look at how we can duplicate the same code with a manual encoding:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'contract MyContract {\n    function doSomething(uint256 myFunctionParam) public {\n        // ... some sort of code goes here\n    }\n}\n\ncontract MyOtherContract {\n    function doTheThing(address myContractAddress, uint256 myFunctionParam) public {\n        myContractAddress.call(\n            abi.encodeWithSignature(\n                "doSomething(uint256)",\n                myFunctionParam\n            )\n        );\n    }\n}\n'})}),(0,i.jsxs)(n.p,{children:["Here we're using the ",(0,i.jsx)(n.a,{href:"https://docs.soliditylang.org/en/v0.8.4/units-and-global-variables.html#members-of-address-types",children:'low-level "call" function'})," and one of the ",(0,i.jsx)(n.a,{href:"https://docs.soliditylang.org/en/v0.8.4/units-and-global-variables.html#abi-encoding-and-decoding-functions",children:"ABI encoding functions built into Solidity"}),"."]}),(0,i.jsx)(n.p,{children:"Although these two code snippets look a bit different, they're actually functionally identical."})]}),"\n",(0,i.jsx)(n.h3,{id:"communication-basics-between-layers",children:"Communication basics between layers"}),"\n",(0,i.jsxs)(n.p,{children:["At a high level, this process is pretty similar to the same process for two contracts on Ethereum (with a few caveats).\n",(0,i.jsx)(n.strong,{children:'Communication between L1 and L2 is enabled by two special smart contracts called the "messengers"'}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Each layer has its own messenger contract which serves to abstract away some lower-level communication details, a lot like how HTTP libraries abstract away physical network connections."}),"\n",(0,i.jsxs)(n.p,{children:["We won't get into ",(0,i.jsx)(n.em,{children:"too"})," much detail about these contracts here \u2014 the only thing you really need to know about is the ",(0,i.jsx)(n.code,{children:"sendMessage"})," function attached to each messenger:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function sendMessage(\n    address _target,\n    bytes memory _message,\n    uint32 _gasLimit\n) public;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It's the same as that ",(0,i.jsx)(n.code,{children:"call"})," function used for contract messaging within L1 Ethereums.\nWe have an extra ",(0,i.jsx)(n.code,{children:"_gasLimit"})," field here, but ",(0,i.jsx)(n.code,{children:"call"})," has that too.\nThis is basically equivalent to:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"address(_target).call{gas: _gasLimit}(_message);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Except, of course, that we're calling a contract on a completely different network."}),"\n",(0,i.jsx)(n.p,{children:"We're glossing over a lot of the technical details that make this whole thing work under the hood.\nPoint is, it works.\nWant to call a contract on Morph from a contract on Ethereum?\nIt's dead simple:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'// Pretend this is on L2\ncontract MyContract {\n    function doSomething(uint256 myFunctionParam) public {\n        // ... some sort of code goes here\n    }\n}\n\n// And pretend this is on L1\ncontract MyOtherContract {\n    function doTheThing(address myOptimisticContractAddress, uint256 myFunctionParam) public {\n        ovmL1CrossDomainMessenger.sendMessage(\n            myOptimisticContractAddress,\n            abi.encodeWithSignature(\n                "doSomething(uint256)",\n                myFunctionParam\n            ),\n            1000000 // use whatever gas limit you want\n        )\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{}),(0,i.jsxs)(n.p,{children:["Using the messenger contracts\nOur messenger contracts, the ",(0,i.jsx)(n.a,{href:"https://github.com/morph-l2/contracts/tree/main/contracts/L1/L1CrossDomainMessenger.sol",children:(0,i.jsx)(n.code,{children:"L1CrossDomainMessenger"})})," and ",(0,i.jsx)(n.a,{href:"https://github.com/morph-l2/contracts/tree/main/contracts/L2/L2CrossDomainMessenger.sol",children:(0,i.jsx)(n.code,{children:"L2CrossDomainMessenger"})}),", always come pre-deployed to each of our networks."]})]}),"\n",(0,i.jsx)(n.h3,{id:"fees-for-l2--l1-transactions",children:"Fees for L2 \u21d2 L1 transactions"}),"\n",(0,i.jsx)(n.p,{children:"Each message from L2 to L1 requires three transactions:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["An L2 transaction that ",(0,i.jsx)(n.em,{children:"initiates"})," the transaction, which is priced the same as any other transaction made on Morph."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["An L1 transaction that ",(0,i.jsx)(n.em,{children:"proves"})," the transaction.\nThis transaction can only be submitted after the state root is submitted to L1.\nThis transaction is expensive because it includes verifying a ",(0,i.jsx)(n.a,{href:"https://eth.wiki/fundamentals/patricia-tree",children:"Merkle trie"})," inclusion proof."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["An L1 transaction that ",(0,i.jsx)(n.em,{children:"finalizes"})," the transaction.\nThis transaction can only be submitted after the transaction challenge period has passed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The total cost of an L2 to L1 transaction is therefore the combined cost of the L2 initialization transaction and the two L1 transactions."}),"\n",(0,i.jsx)(n.p,{children:"The L1 proof and finalization transactions are typically significantly more expensive than the L2 initialization transaction."}),"\n",(0,i.jsx)(n.h3,{id:"understanding-the-challenge-period",children:"Understanding the challenge period"}),"\n",(0,i.jsxs)(n.p,{children:["ne of the most important things to understand about L1 \u21d4 L2 interactions is that ",(0,i.jsx)(n.strong,{children:"messages sent from Layer 2 to Layer 1 cannot be relayed during the challenge period"}),"\n.\nThis means that any messages you send from Layer 2 will only be received on Layer 1 after this period has elapsed."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Read about Morph's unique challenge design based on ",(0,i.jsx)(n.a,{href:"/docs/how-morph-works/responsive-validity-proof/overview",children:"Responsive validity proof"})]})}),"\n",(0,i.jsx)(n.p,{children:'We call this period of time the "challenge period" because it is the time during which a transaction can be challenged.This period is critical for ensuring the integrity of transactions between Layer 2 and Layer 1.'}),"\n",(0,i.jsx)(n.p,{children:"Comparing Rollup Approaches:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"In a basic Optimistic Rollup, identifying and correcting incorrect transactions or states (like a fraudulent withdrawal transaction aiming to redirect your ETH to a hacker's address) requires significant time and effort. This involves interactions with the sequencer to prove the transaction is incorrect."}),"\n",(0,i.jsx)(n.li,{children:"Morph\u2019s approach differs. With Responsive Validity Proof, the sequencer is required to prove their correctness by submitting a zk (zero-knowledge) validity proof. This system necessitates a specific period for challengers to detect issues and initiate a challenge."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Implications for Smart Contracts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It\u2019s crucial not to make decisions about Layer 2 transaction results from within a smart contract on Layer 1 until the challenge period has elapsed. Doing so prematurely might lead to decisions based on invalid transaction results."}),"\n",(0,i.jsx)(n.li,{children:"Consequently, messages sent from Layer 2 to Layer 1, using the standard messenger contracts, cannot be relayed until they have completed the full challenge period."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);