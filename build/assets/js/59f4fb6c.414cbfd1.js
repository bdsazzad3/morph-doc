"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[3186],{56:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var o=t(4848),i=t(8453);const r={title:"Transactions Life Cycle",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},s=void 0,c={id:"how-morph-works/general-protocol-design/transactions-life-cycle",title:"Transactions Life Cycle",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!",source:"@site/docs/how-morph-works/general-protocol-design/4-transactions-life-cycle.md",sourceDirName:"how-morph-works/general-protocol-design",slug:"/how-morph-works/general-protocol-design/transactions-life-cycle",permalink:"/docs/how-morph-works/general-protocol-design/transactions-life-cycle",draft:!1,unlisted:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/how-morph-works/general-protocol-design/4-transactions-life-cycle.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Transactions Life Cycle",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},sidebar:"HowSidebar",previous:{title:"Communication between Morph and Ethereum",permalink:"/docs/how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum"},next:{title:"Difference between Morph and Ethereum",permalink:"/docs/how-morph-works/general-protocol-design/difference-between-ethereum-and-morph"}},a={},l=[{value:"How does a L2 transaction processed on Morph",id:"how-does-a-l2-transaction-processed-on-morph",level:2},{value:"Morph Transaction Status",id:"morph-transaction-status",level:2},{value:"Processing\u200b",id:"processing",level:3},{value:"Confirmed\u200b",id:"confirmed",level:3},{value:"Finalized\u200b",id:"finalized",level:3}];function d(e){const n={h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"how-does-a-l2-transaction-processed-on-morph",children:"How does a L2 transaction processed on Morph"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Submit Transaction"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Users-initiated transactions are first sent to the mempool, where they await selection and processing by a sequencer."}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsx)(n.li,{children:"Transaction Consensus"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Within the sequencer network, transactions undergo a consensus process. A selected sequencer proposes a block containing the transaction. Other sequencers then validate this block, effectively verifying the transaction's legitimacy."}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:"Transaction Execution"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The chosen sequencer orders transactions retrieved from the mempool, executes them sequentially, and updates the local L2 state accordingly."}),"\n",(0,o.jsxs)(n.ol,{start:"4",children:["\n",(0,o.jsx)(n.li,{children:"Transaction Batching"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The sequencer compiles transactions into blocks and subsequently groups these blocks into batches according to specific rules."}),"\n",(0,o.jsxs)(n.ol,{start:"5",children:["\n",(0,o.jsx)(n.li,{children:"Batch Sequencing"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These batches are ultimately submitted to the Layer 1 (L1) contract for both verification and to ensure data availability."}),"\n",(0,o.jsxs)(n.ol,{start:"6",children:["\n",(0,o.jsx)(n.li,{children:"Batch Verification"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"After successfully facing a challenge period and once validated by sequencers, the batches, along with the transactions they contain, are marked as finalized, solidifying their status within the L1 and L2 state."}),"\n",(0,o.jsx)(n.h2,{id:"morph-transaction-status",children:"Morph Transaction Status"}),"\n",(0,o.jsx)(n.h3,{id:"processing",children:"Processing\u200b"}),"\n",(0,o.jsx)(n.p,{children:"Once submitted, a transaction enters the consensus phase managed by sequencers and is placed into a block pre-execution."}),"\n",(0,o.jsx)(n.h3,{id:"confirmed",children:"Confirmed\u200b"}),"\n",(0,o.jsx)(n.p,{children:"Post-execution by the Sequencer, the transaction\u2019s updated state is local to L2. It is then batched and sent to L1, where it must undergo a challenge period before finalization."}),"\n",(0,o.jsx)(n.h3,{id:"finalized",children:"Finalized\u200b"}),"\n",(0,o.jsx)(n.p,{children:"A transaction is considered finalized after it survives the challenge period or is verified by a Zero-Knowledge Proof (ZK-Proof). Only then is it officially integrated into the final L1 and L2 state."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var o=t(6540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);