"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[3457],{5500:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>h});var o=t(3274),r=t(2333);const s={title:"Bridge between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimistic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimistic zk-rollup solution. Try it now!"},i=void 0,a={id:"build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",title:"Bridge between Morph and Ethereum",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimistic zk-rollup solution. Try it now!",source:"@site/docs/build-on-morph/build-on-morph/3-bridge-between-morph-and-ethereum.md",sourceDirName:"build-on-morph/build-on-morph",slug:"/build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",permalink:"/docs/build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",draft:!1,unlisted:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/build-on-morph/build-on-morph/3-bridge-between-morph-and-ethereum.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Bridge between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimistic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimistic zk-rollup solution. Try it now!"},sidebar:"DevSidebar",previous:{title:"Development Setup",permalink:"/docs/build-on-morph/build-on-morph/development-setup"},next:{title:"Understand Transaction Cost on Morph",permalink:"/docs/build-on-morph/build-on-morph/understand-transaction-cost-on-morph"}},d={},h=[{value:"Bridging basics",id:"bridging-basics",level:2},{value:"Sending tokens",id:"sending-tokens",level:3},{value:"Sending data",id:"sending-data",level:3},{value:"Utilize Gateway Contract",id:"utilize-gateway-contract",level:2},{value:"Deposit ETH and ERC20 tokens from L1",id:"deposit-eth-and-erc20-tokens-from-l1",level:2},{value:"Withdraw ETH and ERC20 tokens from L2",id:"withdraw-eth-and-erc20-tokens-from-l2",level:2},{value:"Finalize your Withdraw",id:"finalize-your-withdraw",level:3},{value:"Send messages between Morph and Ethereum",id:"send-messages-between-morph-and-ethereum",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"bridging-basics",children:"Bridging basics"}),"\n",(0,o.jsx)(n.p,{children:"Although Morph is an Ethereum Layer 2 (and therefore fundamentally connected to Ethereum), it's also a separate blockchain system."}),"\n",(0,o.jsx)(n.p,{children:'App developers often have a need to move data and assets between Morph and Ethereum, a process we call "cross layer".'}),"\n",(0,o.jsxs)(n.p,{children:["For how it works under the hood, please check ",(0,o.jsx)(n.a,{href:"/docs/how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum",children:"here"}),":"]}),"\n",(0,o.jsx)(n.p,{children:"For this page we gonna go over how to interact with our cross layer infrastructure to meet your desire purpose."}),"\n",(0,o.jsx)(n.h3,{id:"sending-tokens",children:"Sending tokens"}),"\n",(0,o.jsx)(n.p,{children:'For the most common use case, moving tokens around, we\'ve created the "Token Gateway". The token gate way is a simple smart contract with all the functionality you need to move tokens between Morph and Ethereum.'}),"\n",(0,o.jsx)(n.p,{children:"It also allows you to easily create L2 representations of existing tokens on Ethereum."}),"\n",(0,o.jsx)(n.h3,{id:"sending-data",children:"Sending data"}),"\n",(0,o.jsxs)(n.p,{children:["If the token gateway doesn't fully cover your usecases, you can also ",(0,o.jsx)(n.a,{href:"#send-messages-between-morph-and-ethereum",children:"send arbitrary data between L1 and L2"}),". You can use this functionality to have a contract on Ethereum trigger a contract function on Morph, and vice versa."]}),"\n",(0,o.jsx)(n.p,{children:"We've made this process as easy as possible by giving developers a simple API for triggering a cross-chain function call."}),"\n",(0,o.jsx)(n.h2,{id:"utilize-gateway-contract",children:"Utilize Gateway Contract"}),"\n",(0,o.jsx)(n.p,{children:'To facilitate common interactions like transferring ETH and ERC20 tokens between the two networks, we offer the "Token Gateway". This bridge simplifies the transfer of assets between L1 and L2.'}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'Gateway Functionality: It allows for ETH or ERC20 token to be deposited on L1 and locked in exchange for an equivalent amount on L2, and vice versa. This is known as "bridging a token," e.g., depositing 100 USDC on L1 for 100 USDC on L2. .'}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The Gateway is composed of several contracts on both Layer 1 and Layer 2, which listed as follow:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"L1 Gateway Contract"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L1GatewayRouter"})}),(0,o.jsx)(n.td,{children:"The gateway router supports the deposit of ETH and ERC20 tokens."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L1ETHGateway"})}),(0,o.jsx)(n.td,{children:"The gateway to deposit ETH."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L1StandardERC20Gateway"})}),(0,o.jsx)(n.td,{children:"The gateway for standard ERC20 token deposits."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L1CustomERC20Gateway"})}),(0,o.jsx)(n.td,{children:"The gateway for custom ERC20 token deposits."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L1WETHGateway"})}),(0,o.jsx)(n.td,{children:"The gateway for Wrapped ETH deposits."})]})]})]}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"L2 Gateway Contract"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L2GatewayRouter"})}),(0,o.jsx)(n.td,{children:"The gateway router supports the withdraw of ETH and ERC20 tokens."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L2ETHGateway"})}),(0,o.jsx)(n.td,{children:"The gateway to withdraw ETH."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L2StandardERC20Gateway"})}),(0,o.jsx)(n.td,{children:"The gateway for standard ERC20 token withdraw."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L2CustomERC20Gateway"})}),(0,o.jsx)(n.td,{children:"The gateway for custom ERC20 token withdraw."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"L2WETHGateway"})}),(0,o.jsx)(n.td,{children:"The gateway for Wrapped ETH withdraw."})]})]})]}),"\n",(0,o.jsx)(n.p,{children:"Here we'll go over the basics of using these gateway to move tokens & messages between Layer 1 and Layer 2."}),"\n",(0,o.jsxs)(n.p,{children:["You can find all the contracts details ",(0,o.jsx)(n.a,{href:"/docs/build-on-morph/developer-resources/contracts",children:"here"})]}),"\n",(0,o.jsx)(n.h2,{id:"deposit-eth-and-erc20-tokens-from-l1",children:"Deposit ETH and ERC20 tokens from L1"}),"\n",(0,o.jsxs)(n.p,{children:["The Gateway Router allows ETH and ERC20 token bridging from L1 to L2 using the ",(0,o.jsx)(n.code,{children:"depositETH"})," and ",(0,o.jsx)(n.code,{children:"depositERC20"})," functions respectively. It is a permissionless bridge deployed on L1. Notice that ERC20 tokens will have a different address on L2, you can use the ",(0,o.jsx)(n.code,{children:"getL2ERC20Address"})," function to query the new address."]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"depositETH"})})," and ",(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"depositERC20"})})," are payable functions, the amount of ETH sent to these functions will be used\nto pay for L2 fees. If the amount is not enough, the transaction will not be sent. All excess ETH will be sent back to\nthe sender. ",(0,o.jsx)(n.code,{children:"0.00001 ETH"})," should be more than enough to process a token deposit."]})}),"\n",(0,o.jsxs)(n.p,{children:["When bridging ERC20 tokens, you don\u2019t have to worry about selecting the right Gateway. This is because the ",(0,o.jsx)(n.code,{children:"L1GatewayRouter"})," will choose the correct underlying entry point to send the message:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.code,{children:"L1StandardERC20Gateway"}),":"]})," This Gateway permits any ERC20 deposit and will be selected as the default by the L1GatewayRouter for an ERC20 token that doesn\u2019t need custom logic on L2. On the very first token bridging, a new token will be created on L2 that implements the MorphStandardERC20. To bridge a token, call the ",(0,o.jsx)(n.code,{children:"depositERC20"})," function on the ",(0,o.jsx)(n.code,{children:"L1GatewayRouter"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["All Gateway contracts will form the message and send it to the ",(0,o.jsx)(n.code,{children:"L1CrossDomainMessenger"})," which can send arbitrary messages to L2. The ",(0,o.jsx)(n.code,{children:"L1CrossDomainMessenger"})," passes the message to the ",(0,o.jsx)(n.code,{children:"L1MessageQueueWithGasPriceOracle"}),". Any user can send messages directly to the Messenger to execute arbitrary data on L2."]}),"\n",(0,o.jsx)(n.p,{children:"This means they can execute any function on L2 from a transaction made on L1 via the bridge. Although an application could directly pass messages to existing token contracts, the Gateway abstracts the specifics and simplifies making transfers and calls."}),"\n",(0,o.jsxs)(n.p,{children:["When a new block gets created on L1, the Sequencer will detect the message on the ",(0,o.jsx)(n.code,{children:"L1MessageQueue"}),", and submit the transaction to the L2 via the its L2 node. Finally, the L2 node will pass the transaction to the ",(0,o.jsx)(n.code,{children:"L2CrossDomainMessenger"})," contract for execution on L2."]}),"\n",(0,o.jsx)(n.h2,{id:"withdraw-eth-and-erc20-tokens-from-l2",children:"Withdraw ETH and ERC20 tokens from L2"}),"\n",(0,o.jsxs)(n.p,{children:["The L2 Gateway is very similar to the L1 Gateway. We can withdraw ETH and ERC20 tokens back to L1 using the ",(0,o.jsx)(n.code,{children:"withdrawETH"})," and ",(0,o.jsx)(n.code,{children:"withdrawERC20"})," functions. The contract address is deployed on L2. We use the ",(0,o.jsx)(n.code,{children:"getL1ERC20Address"})," to retrieve the token address on L1."]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"withdrawETH"})})," and ",(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"withdrawERC20"})})," are payable functions, and the amount of ETH sent to these functions will be used to pay for L1 fees. If the amount is not enough, the transaction will not be sent. All excess ETH will be sent back to the sender. Fees will depend on L1 activity but ",(0,o.jsx)(n.code,{children:"0.005 ETH"})," should be enough to process a token withdrawal."]})}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Make sure the transactions won't revert on L1"})," while sending from L2. There is no way to recover bridged ETH, tokens, or NFTs if your transaction reverts on L1. All assets are burnt on Morph when the transaction is sent, and it's impossible to mint them again."]})}),"\n",(0,o.jsx)(n.h3,{id:"finalize-your-withdraw",children:"Finalize your Withdraw"}),"\n",(0,o.jsx)(n.p,{children:"Besides start a withdraw request on Morph, there is one additional step to do. You need to finalize your withdraw on Ethereum."}),"\n",(0,o.jsxs)(n.p,{children:["This is because of Morph's optimistic zkEVM design, you can read the details ",(0,o.jsx)(n.a,{href:"/docs/how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum",children:"here"}),":"]}),"\n",(0,o.jsx)(n.p,{children:"To do this, First you need to make sure:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The batch contains the withdraw transactions has gone through the challenge period and is marked as finalized (which means that in ",(0,o.jsx)(n.code,{children:"Rollup"}),"contract, ",(0,o.jsx)(n.strong,{children:"withdrawalRoots[batchDataStore[_batchIndex].withdrawalRoot] = true"}),")"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Once confirmed, you can call our backend services interface:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"/getProof?nonce=withdraw.index"})}),"\n",(0,o.jsx)(n.p,{children:"to obtain all the information you need to finalize your withdraw, which include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Index: The position of the withdrawal transaction in the withdraw tree, or rank of your transaction among all the L2->L1 transactions."}),"\n",(0,o.jsx)(n.li,{children:"Leaf: The hash value of your withdraw transaction that stored in the tree"}),"\n",(0,o.jsx)(n.li,{children:"Proof: The merkel proof of your withdraw transaction"}),"\n",(0,o.jsx)(n.li,{children:"Root: The withdraw tree root"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[", you need to use the ",(0,o.jsx)(n.code,{children:"proveAndRelayMessage"})," function of the ",(0,o.jsx)(n.code,{children:"L1CrossDomainMessenger"})," contract."]}),"\n",(0,o.jsxs)(n.p,{children:["After obtaining the above information, the finalization of the withdraw operation can be carried out by calling ",(0,o.jsx)(n.code,{children:"L1CrossDomainMessenger.proveAndRelayMessage()"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"The required parameters are"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-solidity",children:"  address _from, \n  address _to, \n  uint256 _value, \n  uint256 _nonce, \n  bytes memory _message, \n  bytes32[32] calldata _withdrawalProof, \n  bytes32 _withdrawalRoot\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"_from"}),",",(0,o.jsx)(n.code,{children:"_to"}),", ",(0,o.jsx)(n.code,{children:"_value"}),", ",(0,o.jsx)(n.code,{children:"_nonce"}),", and ",(0,o.jsx)(n.code,{children:"_message"})," are the original content of the withdraw transaction, which can be obtained from the Event ",(0,o.jsx)(n.code,{children:"SentMessage"})," included in the transaction initiated by the L2 layer withdraw."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"_withdrawalProof"})," and ",(0,o.jsx)(n.code,{children:"_withdrawalRoot"})," can be obtained from the aforementioned backend API interface."]}),"\n",(0,o.jsx)(n.h2,{id:"send-messages-between-morph-and-ethereum",children:"Send messages between Morph and Ethereum"})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},2333:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(9474);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);