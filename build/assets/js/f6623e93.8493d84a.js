"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[6819],{6776:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var t=o(4848),r=o(8453);const i={title:"Morph Modular Design",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},s=void 0,a={id:"how-morph-works/morph-modular-design",title:"Morph Modular Design",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!",source:"@site/docs/how-morph-works/2-morph-modular-design.md",sourceDirName:"how-morph-works",slug:"/how-morph-works/morph-modular-design",permalink:"/docs/how-morph-works/morph-modular-design",draft:!1,unlisted:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/how-morph-works/2-morph-modular-design.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Morph Modular Design",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},sidebar:"HowSidebar",previous:{title:"Introduction",permalink:"/docs/how-morph-works/intro"},next:{title:"Morph's Decentralized Sequencer Network",permalink:"/docs/how-morph-works/decentralized-sequencers/morph-decentralized-sequencer-network"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"3 Major Morph Modules",id:"3-major-morph-modules",level:3},{value:"Sequencer Network - Consensus &amp; Execution",id:"sequencer-network---consensus--execution",level:4},{value:"Optimistic zkEVM - Settlement",id:"optimistic-zkevm---settlement",level:4},{value:"Rollup - Data Avaibility",id:"rollup---data-avaibility",level:4},{value:"5 Morph Roles",id:"5-morph-roles",level:3},{value:"Sequencers",id:"sequencers",level:4},{value:"Prover",id:"prover",level:4},{value:"Validator",id:"validator",level:4},{value:"Nodes",id:"nodes",level:4},{value:"Layer 1",id:"layer-1",level:4},{value:"6 Morph Components",id:"6-morph-components",level:3},{value:"L2 Node",id:"l2-node",level:4},{value:"Transactions Manager (Mempool)",id:"transactions-manager-mempool",level:5},{value:"Executor",id:"executor",level:5},{value:"Synchronizer",id:"synchronizer",level:5},{value:"Batch Submitter",id:"batch-submitter",level:4},{value:"Consensus Client",id:"consensus-client",level:4},{value:"zkEVM",id:"zkevm",level:4},{value:"Aggregators",id:"aggregators",level:4},{value:"Layer 1 Contract",id:"layer-1-contract",level:4},{value:"Components -&gt; Roles -&gt; Modules",id:"components---roles---modules",level:3}];function h(e){const n={a:"a",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Due to its improved composability, the modular design of blockchain has become a trend, and we have incorporated this design into the construction of Morph."}),"\n",(0,t.jsx)(n.p,{children:"Firstly, morphs are divided into three important modules, various roles carry out their respective responsibilities to ensure the module operates seamlessly, with each role being comprised of distinct components. These underlying components effectively collaborate with one another while preserving their individual autonomy."}),"\n",(0,t.jsx)(n.p,{children:"The skeletal architecture of Morph is shown below:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"arichitecture",src:o(8765).A+"",width:"2880",height:"1664"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Modular is generally a term to describe an architectural design idea in which, a Layer 1 blockchain can be divided into four functions:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Consensus"}),"\n",(0,t.jsx)(n.li,{children:"Execution"}),"\n",(0,t.jsx)(n.li,{children:"Data Avaibility"}),"\n",(0,t.jsx)(n.li,{children:"Settlements"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"We believe that Layer 2 can also apply this."}),"\n",(0,t.jsx)(n.p,{children:"Following this, we first divided Morph (or any other Layer 2) into 3 Modules, each module performs the mentioned functionality"}),"\n",(0,t.jsx)(n.h3,{id:"3-major-morph-modules",children:"3 Major Morph Modules"}),"\n",(0,t.jsx)(n.h4,{id:"sequencer-network---consensus--execution",children:"Sequencer Network - Consensus & Execution"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Sequencer Network",src:o(8410).A+"",width:"2880",height:"1670"})}),"\n",(0,t.jsxs)(n.p,{children:["Sequencer network responsible for the execution & consensus of the Layer 2 transactions, for more details please refer to Morph's ",(0,t.jsx)(n.a,{href:"../how-morph-works/decentralized-sequencers/morph-decentralized-sequencer-network",children:"decentralized sequencers"})]}),"\n",(0,t.jsx)(n.h4,{id:"optimistic-zkevm---settlement",children:"Optimistic zkEVM - Settlement"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Optimistic zkEVM",src:o(301).A+"",width:"2880",height:"1704"})}),"\n",(0,t.jsx)(n.p,{children:"For every Layer 2 project, they need to conduct the state verification methods to make sure the state change on Layer 2 is valid on Layer 1."}),"\n",(0,t.jsx)(n.p,{children:"For zkRollups, it's zkEVM, and for optimistic rollups, it's fraud proof."}),"\n",(0,t.jsxs)(n.p,{children:["Morph has the unique design of this, we introduced ",(0,t.jsx)(n.a,{href:"/docs/how-morph-works/responsive-validity-proof/why-rvp",children:"Optimistic zkEVM"})," as a new hybrid solution of state verifications."]}),"\n",(0,t.jsx)(n.p,{children:"The state verification process finalizes and settles Layer 2 transactions and states."}),"\n",(0,t.jsx)(n.h4,{id:"rollup---data-avaibility",children:"Rollup - Data Avaibility"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Rollup",src:o(2178).A+"",width:"1920",height:"1080"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/docs/how-morph-works/general-protocol-design/rollup",children:"Rollup"})," is the process where Layer 2 submits L2 transactions and states to Layer 1."]}),"\n",(0,t.jsx)(n.p,{children:"As a result, all Layer 2 data is accessible on Layer 1, achieving data availability."}),"\n",(0,t.jsx)(n.p,{children:"Morph's rollup strategy maximizes efficiency. A transaction includes multiple batches, and a batch includes multiple blocks. Additionally, leveraging the zk-proof feature, the content of the blocks is compressed to effectively manage the cost of Layer 1 data availability."}),"\n",(0,t.jsx)(n.h3,{id:"5-morph-roles",children:"5 Morph Roles"}),"\n",(0,t.jsx)(n.h4,{id:"sequencers",children:"Sequencers"}),"\n",(0,t.jsx)(n.p,{children:"As the most important part of the network, sequencers serve the following functions:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Receiving Layer 2 users' transactions and form the block (L2 Node)"}),"\n",(0,t.jsx)(n.li,{children:"Reach block consensus with other sequencers (Consensus)"}),"\n",(0,t.jsx)(n.li,{children:"Execute blocks and apply state transmission (L2 Node)"}),"\n",(0,t.jsx)(n.li,{children:"Batch the blocks and submit them to Layer 1 along with the new Layer 2 state ()"}),"\n",(0,t.jsx)(n.li,{children:"Sync the blocks with full nodes"}),"\n",(0,t.jsx)(n.li,{children:"Utilize provers to generate validity proof when being challenged"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"prover",children:"Prover"}),"\n",(0,t.jsx)(n.p,{children:"Prover is an indispensable part of the Morph architecture. When a sequencer is challenged by a validator, in order to prove its innocence, the sequencer needs to call the prover to generate zk proofs for the corresponding state change."}),"\n",(0,t.jsx)(n.p,{children:"The Prover module needs to maintain 3 components: L2 Node, zkEVM and aggregator."}),"\n",(0,t.jsx)(n.p,{children:"It will synchronize the required Layer 2 transaction information through L2 Node and generate corresponding zk proofs through zkEVM component."}),"\n",(0,t.jsx)(n.p,{children:"Under the current framework of Morph, the prover is only called when the sequencer is challenged due to inefficient performance and high cost in generating zk proofs with current technology conditions."}),"\n",(0,t.jsx)(n.p,{children:"After relevant issues are properly resolved in the future, Morph will be converted into a complete ZK Rollup that generates zk proof for each Layer 2 block."}),"\n",(0,t.jsx)(n.h4,{id:"validator",children:"Validator"}),"\n",(0,t.jsx)(n.p,{children:"Validator is a role that can be taken on by any user, and becoming a validator is completely permissionless."}),"\n",(0,t.jsx)(n.p,{children:"Validators need to determine whether the state submitted by the Sequencer to L1 is correct, and the best way to do this is to maintain an L2 Node that synchronizes transactions and state changes in L2."}),"\n",(0,t.jsx)(n.p,{children:"When a validator identifies an incorrect state, they can trigger a challenge by calling the contract's method, which will require the sequencer to generate and submit a zk proof for the challenged block."}),"\n",(0,t.jsx)(n.h4,{id:"nodes",children:"Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Nodes do not actively contribute to the functioning of the network or carry out any tasks; rather, they exist in order to facilitate easier access to the transactions and state of L2."}),"\n",(0,t.jsx)(n.p,{children:"Becoming a node requires running an L2 Node, and this process is open to anyone without the need for permission."}),"\n",(0,t.jsx)(n.p,{children:"Nodes can be categorized as general or archive nodes based on the kind of data they manage, with archive nodes storing a greater amount of state and transaction data than general nodes."}),"\n",(0,t.jsx)(n.h4,{id:"layer-1",children:"Layer 1"}),"\n",(0,t.jsx)(n.p,{children:"Every Layer 2 needs a Layer 1, for Morph, it's Ethereum."}),"\n",(0,t.jsx)(n.p,{children:"Layer 1 serves the role that provides data availability and final settlements."}),"\n",(0,t.jsx)(n.p,{children:"Morph deployed several important contracts to let Layer 1 as the final judges and data storage place. This is a must for all layer 2s if they want to ultimately inherit the safety of Ethereum."}),"\n",(0,t.jsx)(n.h3,{id:"6-morph-components",children:"6 Morph Components"}),"\n",(0,t.jsx)(n.h4,{id:"l2-node",children:"L2 Node"}),"\n",(0,t.jsx)(n.p,{children:"The L2 node plays a pivotal role in overall architectural design, serving as a hub for multiple other modules to interact and exchange information through. Various roles require L2 nodes as an integral part of their normal operation."}),"\n",(0,t.jsx)(n.p,{children:"The L2 node itself is also divided into different components, each with its own specific function:"}),"\n",(0,t.jsx)(n.h5,{id:"transactions-manager-mempool",children:"Transactions Manager (Mempool)"}),"\n",(0,t.jsx)(n.p,{children:"The L2 node will use this component to manage all Layer 2 transactions, including:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Accepting user-initiated transactions and storing them in the Mempool"}),"\n",(0,t.jsx)(n.li,{children:"Responding to the consensus layer by providing the latest transactions from the Mempool for block generation when certain conditions are met"}),"\n",(0,t.jsx)(n.li,{children:"Recording and storing Layer 2 transactions."}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"executor",children:"Executor"}),"\n",(0,t.jsx)(n.p,{children:"The L2 node will maintain the real-time status of Layer 2, and currently Morph has made some modifications to Geth specifically for ZK-Proof, using it as the execution layer. After receiving consensus-approved blocks, the L2 node applies them to the current state to achieve state transition.\nBased on this logic, the execution layer ensures Ethereum compatibility and allows developers to have a consistent development experience."}),"\n",(0,t.jsx)(n.h5,{id:"synchronizer",children:"Synchronizer"}),"\n",(0,t.jsx)(n.p,{children:"There is often a need for synchronization between L2 nodes to restore network status, so the L2 node includes a synchronizer to synchronize data with each other. The frequency and functionality of synchronization vary depending on the role used. For example, for an L2 node running a sequencer, it will first synchronize blocks among various sequencers to achieve consensus, and then synchronize blocks to full nodes. As for full nodes, other roles in the network, such as validator and prover, will synchronize blocks from the full node to complete their work."}),"\n",(0,t.jsx)(n.h4,{id:"batch-submitter",children:"Batch Submitter"}),"\n",(0,t.jsx)(n.p,{children:"Batch Submitter is part of the sequencer, responsible for continuously obtaining L2 Blocks to package them into a Batch and assemble the Batch into a Layer 1 Tx, which is ultimately submitted to the Layer 1 contract."}),"\n",(0,t.jsx)(n.h4,{id:"consensus-client",children:"Consensus Client"}),"\n",(0,t.jsx)(n.p,{children:"Based on our decentralized sequencer network design, each sequencer needs to run its consensus client to reach consensus with other sequencers. In the current design, we use the Tendermint client to ensure friendliness and seamless integration for developers."}),"\n",(0,t.jsx)(n.h4,{id:"zkevm",children:"zkEVM"}),"\n",(0,t.jsx)(n.p,{children:"zkEVM is part of the Prover and is a zk-friendly virtual machine used to generate zkProof for Ethereum blocks and state changes. These zkProofs are ultimately used to prove the validity of L2 transactions and states."}),"\n",(0,t.jsx)(n.h4,{id:"aggregators",children:"Aggregators"}),"\n",(0,t.jsx)(n.p,{children:"Aggregators and zkEVM together form the Prover, which aggregates zk proofs for block production to reduce the cost of verifying zk proofs."}),"\n",(0,t.jsx)(n.h4,{id:"layer-1-contract",children:"Layer 1 Contract"}),"\n",(0,t.jsx)(n.p,{children:"On Layer 1 (Ethereum), each Layer 2 needs to deploy corresponding contracts. The functions of these contracts generally include"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Storing Layer 2 transactions,"}),"\n",(0,t.jsx)(n.li,{children:"Executing global state changes in Layer 2"}),"\n",(0,t.jsx)(n.li,{children:"Bridging assets and information between Layer 2 and Layer 1.\nAdditionally, based on the decentralized sequencer design of Morph, the contracts are responsible for:"}),"\n",(0,t.jsx)(n.li,{children:"Electing and maintaining the sequencer set"}),"\n",(0,t.jsx)(n.li,{children:"Governance"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The existence of these contracts allows Layer 2 to inherit the security of Layer 1, as the invocation and execution of these contracts need to be verified by millions of validators on Ethereum."}),"\n",(0,t.jsx)(n.h3,{id:"components---roles---modules",children:"Components -> Roles -> Modules"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"modular",src:o(9806).A+"",width:"1920",height:"1080"})}),"\n",(0,t.jsx)(n.p,{children:"The underlying layer is the components, and different components together you can perform the duty of the roles we talked about."}),"\n",(0,t.jsx)(n.p,{children:"For example, if you run a L2 node, you can become the role of Node."}),"\n",(0,t.jsx)(n.p,{children:"If you run batch submitter & consensus client too, you can perform the duty of sequencers."}),"\n",(0,t.jsx)(n.p,{children:"And together, these roles can work with each other to realize the major functions."}),"\n",(0,t.jsx)(n.p,{children:"And the major functions together become Morph, a complete Rollup."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},9806:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/modu-01191e93311b938abebd1189bfb69b21.png"},8765:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/archi-d8b8b914a067e8d5f45b4a69e718da83.png"},8410:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/seq1-c64137e0436958fb5e55b9095d0be047.png"},2178:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/rollup-ec0a8c4e6fd4f059adc10a764554bb2d.png"},301:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/opzk-cc4624c8d5a8d928b3c8c24f4e116e1c.png"},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>a});var t=o(6540);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);