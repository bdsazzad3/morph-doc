"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[4908],{5118:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>o,default:()=>a,frontMatter:()=>c,metadata:()=>d,toc:()=>l});var i=n(6070),t=n(1582);const c={title:"Difference between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimistic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimistic zk-rollup solution. Try it now!"},o=void 0,d={id:"how-morph-works/general-protocol-design/difference-between-ethereum-and-morph",title:"Difference between Morph and Ethereum",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimistic zk-rollup solution. Try it now!",source:"@site/docs/how-morph-works/general-protocol-design/5-difference-between-ethereum-and-morph.md",sourceDirName:"how-morph-works/general-protocol-design",slug:"/how-morph-works/general-protocol-design/difference-between-ethereum-and-morph",permalink:"/docs/how-morph-works/general-protocol-design/difference-between-ethereum-and-morph",draft:!1,unlisted:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/how-morph-works/general-protocol-design/5-difference-between-ethereum-and-morph.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Difference between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimistic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimistic zk-rollup solution. Try it now!"},sidebar:"DeveloperSidebar",previous:{title:"Transactions Life Cycle",permalink:"/docs/how-morph-works/general-protocol-design/transactions-life-cycle"},next:{title:"Understand Transaction Cost on Morph",permalink:"/docs/build-on-morph/build-on-morph/understand-transaction-cost-on-morph"}},s={},l=[{value:"EVM Precompiles Difference",id:"evm-precompiles-difference",level:2},{value:"Certain Precompile Limits",id:"certain-precompile-limits",level:3},{value:"EVM Opcodes Difference",id:"evm-opcodes-difference",level:2},{value:"State Account Structure Difference",id:"state-account-structure-difference",level:2},{value:"<strong>Additional Fields</strong>",id:"additional-fields",level:3},{value:"<strong>CodeHash</strong>",id:"codehash",level:3},{value:"Block Time Difference",id:"block-time-difference",level:2}];function h(e){const r={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"There are several technical differences between Ethereum\u2019s EVM and Morph's optimistic zkEVM."}),"\n",(0,i.jsx)(r.p,{children:"We\u2019ve compiled a list to help you understand these distinctions better."}),"\n",(0,i.jsx)(r.p,{children:"For most Solidity developers, these technical details won't significantly impact your development experience."}),"\n",(0,i.jsx)(r.h2,{id:"evm-precompiles-difference",children:"EVM Precompiles Difference"}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"RIPEMD-160"})," (address ",(0,i.jsx)(r.code,{children:"0x3"}),"), ",(0,i.jsx)(r.code,{children:"blake2f"})," (address ",(0,i.jsx)(r.code,{children:"0x9"}),"), and ",(0,i.jsx)(r.code,{children:"point evaluation"})," (address ",(0,i.jsx)(r.code,{children:"0x0a"}),") precompiles are currently unsupported. Calls to these unsupported precompiled contracts will result in a transaction revert."]}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"modexp"})," precompile is supported, but it only accepts inputs that are 32 bytes or smaller (i.e., ",(0,i.jsx)(r.code,{children:"u256"}),")."]}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"ecPairing"})," precompile is also supported; however, the maximum number of points (sets or pairs) is limited to 4, rather than 6."]}),"\n",(0,i.jsxs)(r.p,{children:["All other EVM precompiles are fully supported: ",(0,i.jsx)(r.code,{children:"ecRecover"}),", ",(0,i.jsx)(r.code,{children:"identity"}),", ",(0,i.jsx)(r.code,{children:"ecAdd"}),", and ",(0,i.jsx)(r.code,{children:"ecMul"}),"."]}),"\n",(0,i.jsx)(r.h3,{id:"certain-precompile-limits",children:"Certain Precompile Limits"}),"\n",(0,i.jsx)(r.p,{children:"There is a maximum limit on the number of calls that can be made to certain precompiles due to the bounded size of zkEVM circuits."}),"\n",(0,i.jsx)(r.p,{children:"While these transactions won't be reverted, the sequencer will skip them if they exceed the circuit's capacity."}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Precompile / Opcode"}),(0,i.jsx)(r.th,{children:"Limit"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"keccak256"})}),(0,i.jsx)(r.td,{children:"3157"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"ecRecover"})}),(0,i.jsx)(r.td,{children:"119"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"modexp"})}),(0,i.jsx)(r.td,{children:"23"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"ecAdd"})}),(0,i.jsx)(r.td,{children:"50"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"ecMul"})}),(0,i.jsx)(r.td,{children:"50"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"ecPairing"})}),(0,i.jsx)(r.td,{children:"2"})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"evm-opcodes-difference",children:"EVM Opcodes Difference"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Opcode"}),(0,i.jsx)(r.th,{children:"Solidity equivalent"}),(0,i.jsx)(r.th,{children:"Morph Behavior"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"BLOCKHASH"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"block.blockhash"})}),(0,i.jsxs)(r.td,{children:["Returns ",(0,i.jsx)(r.code,{children:"keccak(chain_id || block_number)"})," for the last 256 blocks."]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"COINBASE"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"block.coinbase"})}),(0,i.jsxs)(r.td,{children:["Returns the pre-deployed fee vault contract address. See ",(0,i.jsx)(r.a,{href:"/docs/build-on-morph/developer-resources/contracts",children:"Contracts"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"DIFFICULTY"})," / ",(0,i.jsx)(r.code,{children:"PREVRANDAO"})]}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"block.difficulty"})}),(0,i.jsx)(r.td,{children:"Returns 0."})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"SELFDESTRUCT"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"selfdestruct"})}),(0,i.jsx)(r.td,{children:"Disabled. If the opcode is triggered, the transaction will be reverted."})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"BLOBHASH"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"tx.blob_versioned_hashes[index]"})}),(0,i.jsx)(r.td,{children:"Not supported"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"BLOBBASEFEE"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"blob_base_fee = BLOBBASEFEE()"})}),(0,i.jsx)(r.td,{children:"Not supported"})]})]})]}),"\n",(0,i.jsxs)(r.admonition,{title:"Several opcode not available",type:"tip",children:[(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"BLOBHASH"})," and ",(0,i.jsx)(r.code,{children:"BLOBBASEFEE"})," are not supported on Morph yet."]}),(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"https://eips.ethereum.org/EIPS/eip-4788",children:"EIP-4788"})," for accessing the Beacon Chain block root is not supported too."]})]}),"\n",(0,i.jsx)(r.h2,{id:"state-account-structure-difference",children:"State Account Structure Difference"}),"\n",(0,i.jsx)(r.h3,{id:"additional-fields",children:(0,i.jsx)(r.strong,{children:"Additional Fields"})}),"\n",(0,i.jsxs)(r.p,{children:["There are two additional fields in the existing ",(0,i.jsx)(r.code,{children:"StateAccount"})," object: ",(0,i.jsx)(r.code,{children:"PoseidonCodehash"})," and ",(0,i.jsx)(r.code,{children:"CodeSize"}),"."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"type StateAccount struct {\n\tNonce    uint64\n\tBalance  *big.Int\n\tRoot     common.Hash // merkle root of the storage trie\n\tKeccakCodeHash []byte // still the Keccak codehash\n\t// added fields\n\tPoseidonCodeHash []byte // the Poseidon codehash\n\tCodeSize uint64\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"codehash",children:(0,i.jsx)(r.strong,{children:"CodeHash"})}),"\n",(0,i.jsxs)(r.p,{children:["In this context, we keep two varieties of code hashes for each contract's bytecode: the ",(0,i.jsx)(r.code,{children:"Keccak hash"})," and the ",(0,i.jsx)(r.code,{children:"Poseidon hash"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"KeccakCodeHash"})," is preserved to ensure compatibility with ",(0,i.jsx)(r.code,{children:"EXTCODEHASH"}),", while the ",(0,i.jsx)(r.code,{children:"PoseidonCodeHash"})," is utilized for verifying the accuracy of bytecodes loaded in the zkEVM, as Poseidon hashing offers significantly greater efficiency."]}),"\n",(0,i.jsx)(r.h2,{id:"block-time-difference",children:"Block Time Difference"}),"\n",(0,i.jsx)(r.admonition,{title:"Block Time Subject to Change",type:"tip",children:(0,i.jsx)(r.p,{children:"Blocks are produced every second, with an empty block generated if there are no transactions for 5 seconds. However, this frequency may change in the future."})}),"\n",(0,i.jsx)(r.p,{children:"To compare, Ethereum has a block time of ~12 seconds."}),"\n",(0,i.jsx)(r.p,{children:"Reasons for Faster Block Time in Morph"}),"\n",(0,i.jsx)(r.p,{children:"User Experience:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"A faster, consistent block time provides quicker feedback, enhancing the user experience."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"Optimization: As we refine the zkEVM circuits in our testnets, we can achieve higher throughput than Ethereum, even with a smaller gas limit per block or batch."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Notice:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"TIMESTAMP"})," will return the timestamp of the block. It will update every second."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"BLOCKNUMBER"})," will return an actual block number. It will update every second. The one-to-one mapping between blocks and transactions will no longer apply."]}),"\n"]})]})}function a(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1582:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>d});var i=n(758);const t={},c=i.createContext(t);function o(e){const r=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(c.Provider,{value:r},e.children)}}}]);