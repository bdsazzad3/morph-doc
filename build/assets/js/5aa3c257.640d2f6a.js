"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[7362],{3328:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>l,frontMatter:()=>n,metadata:()=>o,toc:()=>c});var i=r(4848),s=r(8453);const n={title:"Communication between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},a=void 0,o={id:"how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum",title:"Communication between Morph and Ethereum",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!",source:"@site/docs/how-morph-works/general-protocol-design/2-communicate-between-morph-and-ethereum.md",sourceDirName:"how-morph-works/general-protocol-design",slug:"/how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum",permalink:"/docs/how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum",draft:!1,unlisted:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/how-morph-works/general-protocol-design/2-communicate-between-morph-and-ethereum.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Communication between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},sidebar:"HowSidebar",previous:{title:"Rollup",permalink:"/docs/how-morph-works/general-protocol-design/rollup"},next:{title:"Transactions Life Cycle",permalink:"/docs/how-morph-works/general-protocol-design/transactions-life-cycle"}},h={},c=[{value:"The Basic Idea of the Morph &lt;=&gt; Ethereum Bridge\u200b",id:"the-basic-idea-of-the-morph--ethereum-bridge",level:2},{value:"Deposit (L1 to L2 message)",id:"deposit-l1-to-l2-message",level:2},{value:"Construct a deposit request through Standard Bridge (Optional)",id:"construct-a-deposit-request-through-standard-bridge-optional",level:3},{value:"Pass the message through CrossDomainMessenger",id:"pass-the-message-through-crossdomainmessenger",level:3},{value:"Execute the message on Layer 2",id:"execute-the-message-on-layer-2",level:3},{value:"Withdraw (L2 -&gt; L1 message)",id:"withdraw-l2---l1-message",level:2},{value:"Withdraw Tree",id:"withdraw-tree",level:3},{value:"Verify the withdraw tree",id:"verify-the-withdraw-tree",level:3},{value:"Challenge Period",id:"challenge-period",level:3}];function d(e){const t={code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Although Morph is a Layer 2 solution built atop Ethereum, it remains as a separate and distinct blockchain. Thus, it\u2019s essential to establish a communication channel between Morph and Ethereum to facilitate the smooth transfer of assets and messages. The communication can occur in two directions: from Ethereum to Morph and from Morph to Ethereum."}),"\n",(0,i.jsx)(t.h2,{id:"the-basic-idea-of-the-morph--ethereum-bridge",children:"The Basic Idea of the Morph <=> Ethereum Bridge\u200b"}),"\n",(0,i.jsx)(t.p,{children:'To transfer an asset between Ethereum and Morph, a user must lock the asset in the cross-layer bridge. When the lock is confirmed, Morph mints a Wrapped Token that reflects the value of the locked asset\u2013a process referred to as a "deposit".'}),"\n",(0,i.jsx)(t.p,{children:'Once the minting is complete, a user or intended recipient can claim the asset in Morph. In the reverse scenario, the bridge can unlock the original asset on Ethereum by burning the Wrapped Token, a process called "withdraw".'}),"\n",(0,i.jsx)(t.p,{children:"Furthermore, the bridge\u2019s utility extends beyond asset bridging, as token transfers operate under the same principle as message transfers. The bridge can, therefore, also facilitate cross-layer message bridging, allowing for data payloads to be transported between networks."}),"\n",(0,i.jsx)(t.h2,{id:"deposit-l1-to-l2-message",children:"Deposit (L1 to L2 message)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Deposit Process",src:r(8645).A+"",width:"902",height:"1302"})}),"\n",(0,i.jsx)(t.h3,{id:"construct-a-deposit-request-through-standard-bridge-optional",children:"Construct a deposit request through Standard Bridge (Optional)"}),"\n",(0,i.jsx)(t.p,{children:"A bridge request, whether it is for ETH, ERC20, or ERC721, is essentially a cross-chain message, which necessitates the initial construction of a message. Generally, the message structure remains consistent, especially for ETH & ERC20 token bridges."}),"\n",(0,i.jsxs)(t.p,{children:["Employing a standard bridge assembles a conventional token bridge message and relays it to the ",(0,i.jsx)(t.code,{children:"CrossDomainMessenger"})]}),"\n",(0,i.jsx)(t.h3,{id:"pass-the-message-through-crossdomainmessenger",children:"Pass the message through CrossDomainMessenger"}),"\n",(0,i.jsx)(t.p,{children:"The ```CrossDomainMessenger`` is the basic unit of cross-layer communication.\nThere are messenger contracts on both Layer 1 and Layer 2. For a deposit, the L1 messenger sends a message to the L2 messenger."}),"\n",(0,i.jsx)(t.p,{children:"The interaction mirrors a contract call on Layer 1, which means custom messages (contract interactions) can be constructed to perform various types of cross-layer interactions."}),"\n",(0,i.jsx)(t.h3,{id:"execute-the-message-on-layer-2",children:"Execute the message on Layer 2"}),"\n",(0,i.jsxs)(t.p,{children:["The cross-domain message is delivered to the ",(0,i.jsx)(t.code,{children:"MophismPortal"}),", which then triggers an event called ",(0,i.jsx)(t.code,{children:"TransactionDeposited"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The Sequencer will monitor this event and include a Layer 2 transaction in its next block."}),"\n",(0,i.jsx)(t.p,{children:"A Layer 2 executor, holding the cross-chain message, interacts with the L2 messenger to execute the message, which may include transferring L2 ETH or ERC20 tokens to the recipient."}),"\n",(0,i.jsx)(t.h2,{id:"withdraw-l2---l1-message",children:"Withdraw (L2 -> L1 message)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Withdraw Process",src:r(7001).A+"",width:"1103",height:"1301"})}),"\n",(0,i.jsx)(t.p,{children:"The withdrawal process is, in essence, the inverse of the deposit process, yet it has two main differences."}),"\n",(0,i.jsx)(t.h3,{id:"withdraw-tree",children:"Withdraw Tree"}),"\n",(0,i.jsx)(t.p,{children:"The action of withdrawal means interacting with L1 assets/contracts as a result of a Layer 2 transaction. Consequently, it\u2019s imperative to verify the existence of a Layer 2 transaction that triggers a withdrawal request in a manner that is verifiable on Layer 1."}),"\n",(0,i.jsx)(t.p,{children:"To achieve this, we introduce a structure known as a Withdraw Tree, which records every L2 withdrawal transaction within a Merkel tree. Thus, a Merkel tree's characteristics can be leveraged to confirm the occurrence of a withdrawal request."}),"\n",(0,i.jsx)(t.p,{children:"The term Withdraw Tree refers to an append-only Sparse Merkle Tree (SMT) whose leaf nodes record information on assets being transferred out of the network.\nA leaf within the Withdraw Tree is termed a Withdraw leaf. These withdraw leaves are classified into two types: type 0 for recording asset(s) information and type 1 for recording messaging information."}),"\n",(0,i.jsx)(t.p,{children:"A withdraw leaf, in particular, is a Keccak256 hash of the ABI encoded packed structure with the following parameters:"}),"\n",(0,i.jsx)(t.p,{children:"The Withdraw Tree is instrumental in cataloging withdrawal transactions and ascertaining the legitimacy of withdrawal requests.\nMorph has pre-deployed a Simple Merkle Tree contract dedicated to constructing the Layer 2 withdraw tree."}),"\n",(0,i.jsx)(t.p,{children:"This tree incorporates three methods:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"getTreeroot"})," - return current tree's root hash"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"appendMessageHash"})," - append a new leaf node to the tree"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"verifyMerkleProof"})," - verify if a leaf node existed in the tree (which means bridge request represented by the leaf is valid)"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"verify-the-withdraw-tree",children:"Verify the withdraw tree"}),"\n",(0,i.jsx)(t.p,{children:"A withdrawal request on Layer 2 will culminate in the emission of an event. Our official bridge frontend and SDK provide a service that uses a Tree Prover to construct the appropriate Merkel proof."}),"\n",(0,i.jsxs)(t.p,{children:["Bridgers require this proof to invoke ",(0,i.jsx)(t.code,{children:"proveWithdrawTransaction"})," within the ",(0,i.jsx)(t.code,{children:"MorphPortal"})," contract to substantiate their withdrawal request. Once validated, the withdrawal request will be marked as proven and await finalization."]}),"\n",(0,i.jsx)(t.h3,{id:"challenge-period",children:"Challenge Period"}),"\n",(0,i.jsx)(t.p,{children:"Additionally, because of the Optimistic zkEVM design, every transaction (including withdrawals) on Layer 2 must be submitted to Layer 1 and face a challenge period before finalization."}),"\n",(0,i.jsx)(t.p,{children:"This process is vital to validate the Layer 2 state, including withdrawal transactions. The withdraw tree root, integral for withdrawal request verification, is also submitted by sequencers once the challenge period, batches, and states have been finalized."}),"\n",(0,i.jsx)(t.p,{children:'If the withdrawal is proven and finalized, bridgers may then employ the "MorphPortal" to process the withdrawal on Layer 1.'})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8645:(e,t,r)=>{r.d(t,{A:()=>i});const i=r.p+"assets/images/deposit-255ef9906fc5bd5e93ed7b51d1de02c9.png"},7001:(e,t,r)=>{r.d(t,{A:()=>i});const i=r.p+"assets/images/withdraw-a550ecf89d5c8d8aec0135f88da02148.png"},8453:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>o});var i=r(6540);const s={},n=i.createContext(s);function a(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);